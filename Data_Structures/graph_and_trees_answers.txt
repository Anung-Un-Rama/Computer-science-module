////////////Exercises////////////


1. What is a binary tree and what makes it unique to other trees?

  A: It's a data structure comprised of nodes that point to other nodes children down the line to their right and left. It's unique
  because a node can only have two children. 

2. What is a heuristic?

  A: It's a way that an algorithm solves complex problems faster. But, this will sacrifice a lot of accuracy. 


3. What is another problem besides the shortest-path problem that requires the use of heuristics?

  A: The Traveling Salesman Problem is a classic. 


4. What is the difference between a depth-first search and a breadth-first search?

  A: DFS travels the structure beginning at the root then moving down the branches as far as it can go before doubling back and
  traveling down another branch. BFS travels starting at the root as well, but it instead searches all the neighboring branches
  before heading deeper down to the subsequent levels. 


5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.

  A: The undirected part means that you can travel between two nodes back and forth, then a-cyclic means that the search will not
  loop and thus must be BFS. Unweighted means that it won't assign a cost to the travel (like the amount of distance between nodes).
  So, this means that this graph is a BFS type that can go back and forth between nodes while NOT tracking travel cost. 


6. What kind of graph is a binary search tree?

  A: This sounds like it would be directed, a-cyclic, and unweighted.



///////////Programming Questions/////////


1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.

Example: The value 10 exists in the tree. The value 23 does not exist in the tree.

- Explanation: 

  Beginning at the root, I will compare the value there with the root's value. If the value is greater than the root value, it will
  travel down and to the left to the next child. If this is less than the previous, it will go to the right. This goes so on and so
  forth until the desired value is found or we run out of nodes to search, returning true if found and false if if isn't. 


- Code:


class Node{
  constructor(data, left, right = null){
    this.data = data;
    this.left = left;
    this.right = right;
  }
}

class BST{
  constructor(){
    this.root = null;
  }
  
  search(data){
    let currentNode = this.root;
    while(currentNode != data){
      if(currentNode == null) {
        return false;
      }  
      else if (data < currentNode.data) {
        currentNode = currentNode.left;
      }
      else
      {
        currentNode = currentNode.right;
      }
    }
    return true;   
  }


  add(data){
    const node = this.root;
    if (node === null){
      this.root = new Node(data);
      return;
    } else{
      const searchTree = function(node){
        if (data < node.data){
          if (node.left === null){
            node.left = new Node(data);
            return;
          } else if (node.left !== null){
            return searchTree(node.left);
          }
        } else if (data > node.data){
          if (node.right === null){
            node.right = new Node(data);
            return;
          } else if (node.right !== null){
            return searchTree(node.right);
          }
        } else{
          return null;
        }
      }
      return searchTree(node);
    }
  }

}




2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.

Example: The distance between the nodes 4 and 10 is 4. The distance between the nodes 8 and 10 is 1. The distance between the nodes 1 and 14 is 4.

- Explanation: 

  To find the distance between the two given nodes, we need to find both of their lowest common ancestors, then check the distance
  between the two. 


- Code: 


class Node {
  constructor(data, left, right = null) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}

class BST {
  constructor() {
    this.root = null;
  }
  
  
  findSameAncestor(root, node1, node2) {
    if (!root) return;
    var lowestAncestor = root.data;
    if (node1 == lowestAncestor || node2 == lowestAncestor) {
      return lowestAncestor;
    }
    if (node1 < lowestAncestor && node2 < lowestAncestor) {
      return this.findSameAncestor(root.left, node1, node2);
    }
    if (node1 > lowestAncestor && node2 > lowestAncestor) {
      return this.findSameAncestor(root.right, node1, node2);
    }
    return lowestAncestor;
  }


  countAncestor(root, data) {
    let presentNode = this.root;
    let nodeNumber = 0;
    while (presentNode) {
      if (data == thisNode.data) {
        return nodeNumber;
      }
      presentNode = data < presentNode.data ? presentNode.left : presentNode.right;
      nodeNumber++;
    }
  }


  distanceBetweenNodes(root, node1, node2) {
    let lowestAncestor = this.findSameAncestor(root, node1, node2);
    var node1ToRoot = this.countAncestor(lowestAncestor, node1);
    var node2ToRoot = this.countAncestor(lowestAncestor, node2);
    var rootToAncestor = this.countAncestor(root, lowestAncestor);
  } 


  add(data) {
    const node = this.root;
    if (node === null){
      this.root = new Node(data);
      return;
    } else{
      const searchTree = function(node){
        if (data < node.data){
          if (node.left === null){
            node.left = new Node(data);
            return;
          } else if (node.left !== null){
            return searchTree(node.left);
          }
        } else if (data > node.data){
          if (node.right === null){
            node.right = new Node(data);
            return;
          } else if (node.right !== null){
            return searchTree(node.right);
          }
        } else{
          return null;
        }
      }
      return searchTree(node);
    }
  }

}


